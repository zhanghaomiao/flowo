/* tslint:disable */
/* eslint-disable */
/**
 * flowo
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface JobDetailResponse
 */
export interface JobDetailResponse {
    /**
     * 
     * @type {string}
     * @memberof JobDetailResponse
     */
    'rule_name': string;
    /**
     * 
     * @type {string}
     * @memberof JobDetailResponse
     */
    'workflow_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobDetailResponse
     */
    'status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobDetailResponse
     */
    'started_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobDetailResponse
     */
    'end_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobDetailResponse
     */
    'message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobDetailResponse
     */
    'shellcmd'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobDetailResponse
     */
    'wildcards'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof JobDetailResponse
     */
    'reason'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobDetailResponse
     */
    'resources'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof JobDetailResponse
     */
    'directory'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof JobDetailResponse
     */
    'input'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof JobDetailResponse
     */
    'output': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof JobDetailResponse
     */
    'log'?: Array<string> | null;
}
/**
 * Schema for job list response
 * @export
 * @interface JobListResponse
 */
export interface JobListResponse {
    /**
     * 
     * @type {Array<JobResponse>}
     * @memberof JobListResponse
     */
    'jobs': Array<JobResponse>;
    /**
     * 
     * @type {number}
     * @memberof JobListResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof JobListResponse
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof JobListResponse
     */
    'offset': number;
}
/**
 * Schema for job response
 * @export
 * @interface JobResponse
 */
export interface JobResponse {
    /**
     * 
     * @type {number}
     * @memberof JobResponse
     */
    'id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof JobResponse
     */
    'rule_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'rule_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'workflow_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'started_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'end_time'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof JobResponse
     */
    'threads'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof JobResponse
     */
    'priority'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'shellcmd'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobResponse
     */
    'wildcards'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'reason'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobResponse
     */
    'resources'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface RuleStatusResponse
 */
export interface RuleStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof RuleStatusResponse
     */
    'success': string;
    /**
     * 
     * @type {string}
     * @memberof RuleStatusResponse
     */
    'running': string;
    /**
     * 
     * @type {string}
     * @memberof RuleStatusResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof RuleStatusResponse
     */
    'total': string;
    /**
     * 
     * @type {string}
     * @memberof RuleStatusResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Status = {
    Error: 'ERROR',
    Running: 'RUNNING',
    Success: 'SUCCESS',
    Waiting: 'WAITING',
    Unknown: 'UNKNOWN'
} as const;

export type Status = typeof Status[keyof typeof Status];


/**
 * 
 * @export
 * @interface StatusSummary
 */
export interface StatusSummary {
    /**
     * 
     * @type {number}
     * @memberof StatusSummary
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof StatusSummary
     */
    'success': number;
    /**
     * 
     * @type {number}
     * @memberof StatusSummary
     */
    'running': number;
    /**
     * 
     * @type {number}
     * @memberof StatusSummary
     */
    'error': number;
}
/**
 * 
 * @export
 * @interface TreeDataNode
 */
export interface TreeDataNode {
    /**
     * 
     * @type {string}
     * @memberof TreeDataNode
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof TreeDataNode
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof TreeDataNode
     */
    'icon'?: string | null;
    /**
     * 
     * @type {Array<TreeDataNode>}
     * @memberof TreeDataNode
     */
    'children'?: Array<TreeDataNode> | null;
    /**
     * 
     * @type {boolean}
     * @memberof TreeDataNode
     */
    'isLeaf'?: boolean | null;
}
/**
 * 
 * @export
 * @interface UserSummary
 */
export interface UserSummary {
    /**
     * 
     * @type {number}
     * @memberof UserSummary
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof UserSummary
     */
    'running': number;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}
/**
 * 
 * @export
 * @interface WorkflowDetialResponse
 */
export interface WorkflowDetialResponse {
    /**
     * 
     * @type {string}
     * @memberof WorkflowDetialResponse
     */
    'workflow_id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowDetialResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowDetialResponse
     */
    'user'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkflowDetialResponse
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowDetialResponse
     */
    'started_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowDetialResponse
     */
    'end_time': string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowDetialResponse
     */
    'status': string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowDetialResponse
     */
    'progress'?: number | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WorkflowDetialResponse
     */
    'config'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowDetialResponse
     */
    'snakefile': string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowDetialResponse
     */
    'directory'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkflowDetialResponse
     */
    'configfiles'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowDetialResponse
     */
    'flowo_directory'?: string | null;
}
/**
 * Schema for workflow list response
 * @export
 * @interface WorkflowListResponse
 */
export interface WorkflowListResponse {
    /**
     * 
     * @type {Array<WorkflowResponse>}
     * @memberof WorkflowListResponse
     */
    'workflows': Array<WorkflowResponse>;
    /**
     * 
     * @type {number}
     * @memberof WorkflowListResponse
     */
    'total': number | null;
    /**
     * 
     * @type {number}
     * @memberof WorkflowListResponse
     */
    'limit': number | null;
    /**
     * 
     * @type {number}
     * @memberof WorkflowListResponse
     */
    'offset': number | null;
}
/**
 * Schema for workflow response
 * @export
 * @interface WorkflowResponse
 */
export interface WorkflowResponse {
    /**
     * 
     * @type {string}
     * @memberof WorkflowResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResponse
     */
    'directory'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowResponse
     */
    'snakefile': boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResponse
     */
    'started_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResponse
     */
    'end_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResponse
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResponse
     */
    'user'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowResponse
     */
    'configfiles': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkflowResponse
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof WorkflowResponse
     */
    'progress'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WorkflowResponse
     */
    'total_jobs': number;
}

/**
 * JobsApi - axios parameter creator
 * @export
 */
export const JobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Job
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobApiV1JobsJobIdDetailGet: async (jobId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobApiV1JobsJobIdDetailGet', 'jobId', jobId)
            const localVarPath = `/api/v1/jobs/{job_id}/detail`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Logs
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogsApiV1JobsJobIdLogsGet: async (jobId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getLogsApiV1JobsJobIdLogsGet', 'jobId', jobId)
            const localVarPath = `/api/v1/jobs/{job_id}/logs`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Job
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobApiV1JobsJobIdDetailGet(jobId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobApiV1JobsJobIdDetailGet(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.getJobApiV1JobsJobIdDetailGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Logs
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogsApiV1JobsJobIdLogsGet(jobId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogsApiV1JobsJobIdLogsGet(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.getLogsApiV1JobsJobIdLogsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Job
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobApiV1JobsJobIdDetailGet(jobId: number, options?: RawAxiosRequestConfig): AxiosPromise<JobDetailResponse> {
            return localVarFp.getJobApiV1JobsJobIdDetailGet(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Logs
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogsApiV1JobsJobIdLogsGet(jobId: number, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getLogsApiV1JobsJobIdLogsGet(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * 
     * @summary Get Job
     * @param {number} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobApiV1JobsJobIdDetailGet(jobId: number, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).getJobApiV1JobsJobIdDetailGet(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Logs
     * @param {number} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getLogsApiV1JobsJobIdLogsGet(jobId: number, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).getLogsApiV1JobsJobIdLogsGet(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LogsApi - axios parameter creator
 * @export
 */
export const LogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Workflow Logs
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowLogsApiV1LogsWorkflowIdGet: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getWorkflowLogsApiV1LogsWorkflowIdGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/logs/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 使用Server-Sent Events格式的实时日志流
         * @summary Stream Workflow Logs Sse
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamWorkflowLogsSseApiV1LogsWorkflowIdSseGet: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('streamWorkflowLogsSseApiV1LogsWorkflowIdSseGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/logs/{workflow_id}/sse`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogsApi - functional programming interface
 * @export
 */
export const LogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Workflow Logs
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowLogsApiV1LogsWorkflowIdGet(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowLogsApiV1LogsWorkflowIdGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogsApi.getWorkflowLogsApiV1LogsWorkflowIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 使用Server-Sent Events格式的实时日志流
         * @summary Stream Workflow Logs Sse
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamWorkflowLogsSseApiV1LogsWorkflowIdSseGet(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamWorkflowLogsSseApiV1LogsWorkflowIdSseGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogsApi.streamWorkflowLogsSseApiV1LogsWorkflowIdSseGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LogsApi - factory interface
 * @export
 */
export const LogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Workflow Logs
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowLogsApiV1LogsWorkflowIdGet(workflowId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getWorkflowLogsApiV1LogsWorkflowIdGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 使用Server-Sent Events格式的实时日志流
         * @summary Stream Workflow Logs Sse
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamWorkflowLogsSseApiV1LogsWorkflowIdSseGet(workflowId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.streamWorkflowLogsSseApiV1LogsWorkflowIdSseGet(workflowId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogsApi - object-oriented interface
 * @export
 * @class LogsApi
 * @extends {BaseAPI}
 */
export class LogsApi extends BaseAPI {
    /**
     * 
     * @summary Get Workflow Logs
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public getWorkflowLogsApiV1LogsWorkflowIdGet(workflowId: string, options?: RawAxiosRequestConfig) {
        return LogsApiFp(this.configuration).getWorkflowLogsApiV1LogsWorkflowIdGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 使用Server-Sent Events格式的实时日志流
     * @summary Stream Workflow Logs Sse
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public streamWorkflowLogsSseApiV1LogsWorkflowIdSseGet(workflowId: string, options?: RawAxiosRequestConfig) {
        return LogsApiFp(this.configuration).streamWorkflowLogsSseApiV1LogsWorkflowIdSseGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OutputsApi - axios parameter creator
 * @export
 */
export const OutputsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Job Outputs
         * @param {string} workflowId 
         * @param {string} ruleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobOutputsApiV1OutputsWorkflowIdRuleOutputsGet: async (workflowId: string, ruleName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getJobOutputsApiV1OutputsWorkflowIdRuleOutputsGet', 'workflowId', workflowId)
            // verify required parameter 'ruleName' is not null or undefined
            assertParamExists('getJobOutputsApiV1OutputsWorkflowIdRuleOutputsGet', 'ruleName', ruleName)
            const localVarPath = `/api/v1/outputs/{workflow_id}/rule_outputs`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ruleName !== undefined) {
                localVarQueryParameter['rule_name'] = ruleName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Outputs
         * @param {string} workflowId 
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOutputsApiV1OutputsWorkflowIdOutputsGet: async (workflowId: string, maxDepth?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getOutputsApiV1OutputsWorkflowIdOutputsGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/outputs/{workflow_id}/outputs`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxDepth !== undefined) {
                localVarQueryParameter['max_depth'] = maxDepth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OutputsApi - functional programming interface
 * @export
 */
export const OutputsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OutputsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Job Outputs
         * @param {string} workflowId 
         * @param {string} ruleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobOutputsApiV1OutputsWorkflowIdRuleOutputsGet(workflowId: string, ruleName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string | null>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobOutputsApiV1OutputsWorkflowIdRuleOutputsGet(workflowId, ruleName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutputsApi.getJobOutputsApiV1OutputsWorkflowIdRuleOutputsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Outputs
         * @param {string} workflowId 
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOutputsApiV1OutputsWorkflowIdOutputsGet(workflowId: string, maxDepth?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeDataNode>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOutputsApiV1OutputsWorkflowIdOutputsGet(workflowId, maxDepth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutputsApi.getOutputsApiV1OutputsWorkflowIdOutputsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OutputsApi - factory interface
 * @export
 */
export const OutputsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OutputsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Job Outputs
         * @param {string} workflowId 
         * @param {string} ruleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobOutputsApiV1OutputsWorkflowIdRuleOutputsGet(workflowId: string, ruleName: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string | null>> {
            return localVarFp.getJobOutputsApiV1OutputsWorkflowIdRuleOutputsGet(workflowId, ruleName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Outputs
         * @param {string} workflowId 
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOutputsApiV1OutputsWorkflowIdOutputsGet(workflowId: string, maxDepth?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<TreeDataNode>> {
            return localVarFp.getOutputsApiV1OutputsWorkflowIdOutputsGet(workflowId, maxDepth, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OutputsApi - object-oriented interface
 * @export
 * @class OutputsApi
 * @extends {BaseAPI}
 */
export class OutputsApi extends BaseAPI {
    /**
     * 
     * @summary Get Job Outputs
     * @param {string} workflowId 
     * @param {string} ruleName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutputsApi
     */
    public getJobOutputsApiV1OutputsWorkflowIdRuleOutputsGet(workflowId: string, ruleName: string, options?: RawAxiosRequestConfig) {
        return OutputsApiFp(this.configuration).getJobOutputsApiV1OutputsWorkflowIdRuleOutputsGet(workflowId, ruleName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Outputs
     * @param {string} workflowId 
     * @param {number} [maxDepth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutputsApi
     */
    public getOutputsApiV1OutputsWorkflowIdOutputsGet(workflowId: string, maxDepth?: number, options?: RawAxiosRequestConfig) {
        return OutputsApiFp(this.configuration).getOutputsApiV1OutputsWorkflowIdOutputsGet(workflowId, maxDepth, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SseApi - axios parameter creator
 * @export
 */
export const SseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cleanup Connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupConnectionsApiV1SseCleanupConnectionsPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sse/cleanup-connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Debug Connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugConnectionsApiV1SseDebugConnectionsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sse/debug/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Force Reconnect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceReconnectApiV1SseReconnectPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sse/reconnect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Sse Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSseStatsApiV1SseStatsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sse/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send Test Notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestNotificationApiV1SseTestNotificationPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sse/test-notification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sse Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sseHealthCheckApiV1SseHealthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sse/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Server-Sent Events endpoint for real-time database notifications.  客户端可以连接此端点接收实时通知: - GET /api/v1/sse/events - 接收所有表变化 - GET /api/v1/sse/events?filters=workflows - 只接收workflows表变化 - GET /api/v1/sse/events?filters=jobs&workflow_id=123 - 接收workflows和jobs表变化
         * @summary Stream Events
         * @param {string | null} [filters] Comma-separated list of table names to filter (e.g., \&#39;workflows,jobs\&#39;). Use \&#39;all\&#39; for all tables.
         * @param {string | null} [workflowId] Workflow ID to filter events for a specific workflow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamEventsApiV1SseEventsGet: async (filters?: string | null, workflowId?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sse/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (workflowId !== undefined) {
                localVarQueryParameter['workflow_id'] = workflowId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SseApi - functional programming interface
 * @export
 */
export const SseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cleanup Connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanupConnectionsApiV1SseCleanupConnectionsPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanupConnectionsApiV1SseCleanupConnectionsPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SseApi.cleanupConnectionsApiV1SseCleanupConnectionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Debug Connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debugConnectionsApiV1SseDebugConnectionsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debugConnectionsApiV1SseDebugConnectionsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SseApi.debugConnectionsApiV1SseDebugConnectionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Force Reconnect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forceReconnectApiV1SseReconnectPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forceReconnectApiV1SseReconnectPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SseApi.forceReconnectApiV1SseReconnectPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Sse Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSseStatsApiV1SseStatsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSseStatsApiV1SseStatsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SseApi.getSseStatsApiV1SseStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send Test Notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTestNotificationApiV1SseTestNotificationPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendTestNotificationApiV1SseTestNotificationPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SseApi.sendTestNotificationApiV1SseTestNotificationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sse Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sseHealthCheckApiV1SseHealthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sseHealthCheckApiV1SseHealthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SseApi.sseHealthCheckApiV1SseHealthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Server-Sent Events endpoint for real-time database notifications.  客户端可以连接此端点接收实时通知: - GET /api/v1/sse/events - 接收所有表变化 - GET /api/v1/sse/events?filters=workflows - 只接收workflows表变化 - GET /api/v1/sse/events?filters=jobs&workflow_id=123 - 接收workflows和jobs表变化
         * @summary Stream Events
         * @param {string | null} [filters] Comma-separated list of table names to filter (e.g., \&#39;workflows,jobs\&#39;). Use \&#39;all\&#39; for all tables.
         * @param {string | null} [workflowId] Workflow ID to filter events for a specific workflow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamEventsApiV1SseEventsGet(filters?: string | null, workflowId?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamEventsApiV1SseEventsGet(filters, workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SseApi.streamEventsApiV1SseEventsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SseApi - factory interface
 * @export
 */
export const SseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SseApiFp(configuration)
    return {
        /**
         * 
         * @summary Cleanup Connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupConnectionsApiV1SseCleanupConnectionsPost(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.cleanupConnectionsApiV1SseCleanupConnectionsPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Debug Connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugConnectionsApiV1SseDebugConnectionsGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.debugConnectionsApiV1SseDebugConnectionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Force Reconnect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceReconnectApiV1SseReconnectPost(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.forceReconnectApiV1SseReconnectPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Sse Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSseStatsApiV1SseStatsGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getSseStatsApiV1SseStatsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send Test Notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestNotificationApiV1SseTestNotificationPost(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.sendTestNotificationApiV1SseTestNotificationPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sse Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sseHealthCheckApiV1SseHealthGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.sseHealthCheckApiV1SseHealthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Server-Sent Events endpoint for real-time database notifications.  客户端可以连接此端点接收实时通知: - GET /api/v1/sse/events - 接收所有表变化 - GET /api/v1/sse/events?filters=workflows - 只接收workflows表变化 - GET /api/v1/sse/events?filters=jobs&workflow_id=123 - 接收workflows和jobs表变化
         * @summary Stream Events
         * @param {string | null} [filters] Comma-separated list of table names to filter (e.g., \&#39;workflows,jobs\&#39;). Use \&#39;all\&#39; for all tables.
         * @param {string | null} [workflowId] Workflow ID to filter events for a specific workflow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamEventsApiV1SseEventsGet(filters?: string | null, workflowId?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.streamEventsApiV1SseEventsGet(filters, workflowId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SseApi - object-oriented interface
 * @export
 * @class SseApi
 * @extends {BaseAPI}
 */
export class SseApi extends BaseAPI {
    /**
     * 
     * @summary Cleanup Connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SseApi
     */
    public cleanupConnectionsApiV1SseCleanupConnectionsPost(options?: RawAxiosRequestConfig) {
        return SseApiFp(this.configuration).cleanupConnectionsApiV1SseCleanupConnectionsPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Debug Connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SseApi
     */
    public debugConnectionsApiV1SseDebugConnectionsGet(options?: RawAxiosRequestConfig) {
        return SseApiFp(this.configuration).debugConnectionsApiV1SseDebugConnectionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Force Reconnect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SseApi
     */
    public forceReconnectApiV1SseReconnectPost(options?: RawAxiosRequestConfig) {
        return SseApiFp(this.configuration).forceReconnectApiV1SseReconnectPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Sse Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SseApi
     */
    public getSseStatsApiV1SseStatsGet(options?: RawAxiosRequestConfig) {
        return SseApiFp(this.configuration).getSseStatsApiV1SseStatsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send Test Notification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SseApi
     */
    public sendTestNotificationApiV1SseTestNotificationPost(options?: RawAxiosRequestConfig) {
        return SseApiFp(this.configuration).sendTestNotificationApiV1SseTestNotificationPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sse Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SseApi
     */
    public sseHealthCheckApiV1SseHealthGet(options?: RawAxiosRequestConfig) {
        return SseApiFp(this.configuration).sseHealthCheckApiV1SseHealthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Server-Sent Events endpoint for real-time database notifications.  客户端可以连接此端点接收实时通知: - GET /api/v1/sse/events - 接收所有表变化 - GET /api/v1/sse/events?filters=workflows - 只接收workflows表变化 - GET /api/v1/sse/events?filters=jobs&workflow_id=123 - 接收workflows和jobs表变化
     * @summary Stream Events
     * @param {string | null} [filters] Comma-separated list of table names to filter (e.g., \&#39;workflows,jobs\&#39;). Use \&#39;all\&#39; for all tables.
     * @param {string | null} [workflowId] Workflow ID to filter events for a specific workflow.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SseApi
     */
    public streamEventsApiV1SseEventsGet(filters?: string | null, workflowId?: string | null, options?: RawAxiosRequestConfig) {
        return SseApiFp(this.configuration).streamEventsApiV1SseEventsGet(filters, workflowId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SummaryApi - axios parameter creator
 * @export
 */
export const SummaryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Activity
         * @param {GetActivityApiV1SummaryActivityGetItemEnum} item 
         * @param {string | null} [startAt] 
         * @param {string | null} [endAt] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityApiV1SummaryActivityGet: async (item: GetActivityApiV1SummaryActivityGetItemEnum, startAt?: string | null, endAt?: string | null, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('getActivityApiV1SummaryActivityGet', 'item', item)
            const localVarPath = `/api/v1/summary/activity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (item !== undefined) {
                localVarQueryParameter['item'] = item;
            }

            if (startAt !== undefined) {
                localVarQueryParameter['start_at'] = (startAt as any instanceof Date) ?
                    (startAt as any).toISOString() :
                    startAt;
            }

            if (endAt !== undefined) {
                localVarQueryParameter['end_at'] = (endAt as any instanceof Date) ?
                    (endAt as any).toISOString() :
                    endAt;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Rule Duration
         * @param {string | null} [startAt] 
         * @param {string | null} [endAt] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleDurationApiV1SummaryRuleDurationGet: async (startAt?: string | null, endAt?: string | null, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/summary/rule_duration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startAt !== undefined) {
                localVarQueryParameter['start_at'] = (startAt as any instanceof Date) ?
                    (startAt as any).toISOString() :
                    startAt;
            }

            if (endAt !== undefined) {
                localVarQueryParameter['end_at'] = (endAt as any instanceof Date) ?
                    (endAt as any).toISOString() :
                    endAt;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Rule Error
         * @param {string | null} [startAt] 
         * @param {string | null} [endAt] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleErrorApiV1SummaryRuleErrorGet: async (startAt?: string | null, endAt?: string | null, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/summary/rule_error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startAt !== undefined) {
                localVarQueryParameter['start_at'] = (startAt as any instanceof Date) ?
                    (startAt as any).toISOString() :
                    startAt;
            }

            if (endAt !== undefined) {
                localVarQueryParameter['end_at'] = (endAt as any instanceof Date) ?
                    (endAt as any).toISOString() :
                    endAt;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Status
         * @param {GetStatusApiV1SummaryStatusGetItemEnum} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusApiV1SummaryStatusGet: async (item: GetStatusApiV1SummaryStatusGetItemEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('getStatusApiV1SummaryStatusGet', 'item', item)
            const localVarPath = `/api/v1/summary/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (item !== undefined) {
                localVarQueryParameter['item'] = item;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get System Resources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemResourcesApiV1SummaryResourcesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/summary/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User Summary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSummaryApiV1SummaryUserGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/summary/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Pruning
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPruningApiV1SummaryPruningPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/summary/pruning`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SummaryApi - functional programming interface
 * @export
 */
export const SummaryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SummaryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Activity
         * @param {GetActivityApiV1SummaryActivityGetItemEnum} item 
         * @param {string | null} [startAt] 
         * @param {string | null} [endAt] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityApiV1SummaryActivityGet(item: GetActivityApiV1SummaryActivityGetItemEnum, startAt?: string | null, endAt?: string | null, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivityApiV1SummaryActivityGet(item, startAt, endAt, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SummaryApi.getActivityApiV1SummaryActivityGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Rule Duration
         * @param {string | null} [startAt] 
         * @param {string | null} [endAt] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRuleDurationApiV1SummaryRuleDurationGet(startAt?: string | null, endAt?: string | null, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: { [key: string]: number; }; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRuleDurationApiV1SummaryRuleDurationGet(startAt, endAt, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SummaryApi.getRuleDurationApiV1SummaryRuleDurationGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Rule Error
         * @param {string | null} [startAt] 
         * @param {string | null} [endAt] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRuleErrorApiV1SummaryRuleErrorGet(startAt?: string | null, endAt?: string | null, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: { [key: string]: any; }; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRuleErrorApiV1SummaryRuleErrorGet(startAt, endAt, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SummaryApi.getRuleErrorApiV1SummaryRuleErrorGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Status
         * @param {GetStatusApiV1SummaryStatusGetItemEnum} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusApiV1SummaryStatusGet(item: GetStatusApiV1SummaryStatusGetItemEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusApiV1SummaryStatusGet(item, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SummaryApi.getStatusApiV1SummaryStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get System Resources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemResourcesApiV1SummaryResourcesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemResourcesApiV1SummaryResourcesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SummaryApi.getSystemResourcesApiV1SummaryResourcesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get User Summary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSummaryApiV1SummaryUserGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSummaryApiV1SummaryUserGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SummaryApi.getUserSummaryApiV1SummaryUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Post Pruning
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPruningApiV1SummaryPruningPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPruningApiV1SummaryPruningPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SummaryApi.postPruningApiV1SummaryPruningPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SummaryApi - factory interface
 * @export
 */
export const SummaryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SummaryApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Activity
         * @param {GetActivityApiV1SummaryActivityGetItemEnum} item 
         * @param {string | null} [startAt] 
         * @param {string | null} [endAt] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityApiV1SummaryActivityGet(item: GetActivityApiV1SummaryActivityGetItemEnum, startAt?: string | null, endAt?: string | null, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.getActivityApiV1SummaryActivityGet(item, startAt, endAt, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Rule Duration
         * @param {string | null} [startAt] 
         * @param {string | null} [endAt] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleDurationApiV1SummaryRuleDurationGet(startAt?: string | null, endAt?: string | null, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: { [key: string]: number; }; }> {
            return localVarFp.getRuleDurationApiV1SummaryRuleDurationGet(startAt, endAt, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Rule Error
         * @param {string | null} [startAt] 
         * @param {string | null} [endAt] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleErrorApiV1SummaryRuleErrorGet(startAt?: string | null, endAt?: string | null, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: { [key: string]: any; }; }> {
            return localVarFp.getRuleErrorApiV1SummaryRuleErrorGet(startAt, endAt, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Status
         * @param {GetStatusApiV1SummaryStatusGetItemEnum} item 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusApiV1SummaryStatusGet(item: GetStatusApiV1SummaryStatusGetItemEnum, options?: RawAxiosRequestConfig): AxiosPromise<StatusSummary> {
            return localVarFp.getStatusApiV1SummaryStatusGet(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get System Resources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemResourcesApiV1SummaryResourcesGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getSystemResourcesApiV1SummaryResourcesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User Summary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSummaryApiV1SummaryUserGet(options?: RawAxiosRequestConfig): AxiosPromise<UserSummary> {
            return localVarFp.getUserSummaryApiV1SummaryUserGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Pruning
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPruningApiV1SummaryPruningPost(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.postPruningApiV1SummaryPruningPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SummaryApi - object-oriented interface
 * @export
 * @class SummaryApi
 * @extends {BaseAPI}
 */
export class SummaryApi extends BaseAPI {
    /**
     * 
     * @summary Get Activity
     * @param {GetActivityApiV1SummaryActivityGetItemEnum} item 
     * @param {string | null} [startAt] 
     * @param {string | null} [endAt] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SummaryApi
     */
    public getActivityApiV1SummaryActivityGet(item: GetActivityApiV1SummaryActivityGetItemEnum, startAt?: string | null, endAt?: string | null, limit?: number, options?: RawAxiosRequestConfig) {
        return SummaryApiFp(this.configuration).getActivityApiV1SummaryActivityGet(item, startAt, endAt, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Rule Duration
     * @param {string | null} [startAt] 
     * @param {string | null} [endAt] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SummaryApi
     */
    public getRuleDurationApiV1SummaryRuleDurationGet(startAt?: string | null, endAt?: string | null, limit?: number, options?: RawAxiosRequestConfig) {
        return SummaryApiFp(this.configuration).getRuleDurationApiV1SummaryRuleDurationGet(startAt, endAt, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Rule Error
     * @param {string | null} [startAt] 
     * @param {string | null} [endAt] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SummaryApi
     */
    public getRuleErrorApiV1SummaryRuleErrorGet(startAt?: string | null, endAt?: string | null, limit?: number, options?: RawAxiosRequestConfig) {
        return SummaryApiFp(this.configuration).getRuleErrorApiV1SummaryRuleErrorGet(startAt, endAt, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Status
     * @param {GetStatusApiV1SummaryStatusGetItemEnum} item 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SummaryApi
     */
    public getStatusApiV1SummaryStatusGet(item: GetStatusApiV1SummaryStatusGetItemEnum, options?: RawAxiosRequestConfig) {
        return SummaryApiFp(this.configuration).getStatusApiV1SummaryStatusGet(item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get System Resources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SummaryApi
     */
    public getSystemResourcesApiV1SummaryResourcesGet(options?: RawAxiosRequestConfig) {
        return SummaryApiFp(this.configuration).getSystemResourcesApiV1SummaryResourcesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User Summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SummaryApi
     */
    public getUserSummaryApiV1SummaryUserGet(options?: RawAxiosRequestConfig) {
        return SummaryApiFp(this.configuration).getUserSummaryApiV1SummaryUserGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Pruning
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SummaryApi
     */
    public postPruningApiV1SummaryPruningPost(options?: RawAxiosRequestConfig) {
        return SummaryApiFp(this.configuration).postPruningApiV1SummaryPruningPost(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetActivityApiV1SummaryActivityGetItemEnum = {
    Rule: 'rule',
    User: 'user',
    Tag: 'tag'
} as const;
export type GetActivityApiV1SummaryActivityGetItemEnum = typeof GetActivityApiV1SummaryActivityGetItemEnum[keyof typeof GetActivityApiV1SummaryActivityGetItemEnum];
/**
 * @export
 */
export const GetStatusApiV1SummaryStatusGetItemEnum = {
    Job: 'job',
    Workflow: 'workflow'
} as const;
export type GetStatusApiV1SummaryStatusGetItemEnum = typeof GetStatusApiV1SummaryStatusGetItemEnum[keyof typeof GetStatusApiV1SummaryStatusGetItemEnum];


/**
 * UtilsApi - axios parameter creator
 * @export
 */
export const UtilsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get All Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTagsApiV1UtilsTagsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/utils/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UtilsApi - functional programming interface
 * @export
 */
export const UtilsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UtilsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get All Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTagsApiV1UtilsTagsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string | null>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTagsApiV1UtilsTagsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UtilsApi.getAllTagsApiV1UtilsTagsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UtilsApi - factory interface
 * @export
 */
export const UtilsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UtilsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get All Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTagsApiV1UtilsTagsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<string | null>> {
            return localVarFp.getAllTagsApiV1UtilsTagsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UtilsApi - object-oriented interface
 * @export
 * @class UtilsApi
 * @extends {BaseAPI}
 */
export class UtilsApi extends BaseAPI {
    /**
     * 
     * @summary Get All Tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilsApi
     */
    public getAllTagsApiV1UtilsTagsGet(options?: RawAxiosRequestConfig) {
        return UtilsApiFp(this.configuration).getAllTagsApiV1UtilsTagsGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkflowApi - axios parameter creator
 * @export
 */
export const WorkflowApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowApiV1WorkflowsWorkflowIdDelete: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('deleteWorkflowApiV1WorkflowsWorkflowIdDelete', 'workflowId', workflowId)
            const localVarPath = `/api/v1/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersApiV1WorkflowsUsersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflows/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Configfiles
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigfilesApiV1WorkflowsWorkflowIdConfigfilesGet: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getConfigfilesApiV1WorkflowsWorkflowIdConfigfilesGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/workflows/{workflow_id}/configfiles`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Detail
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailApiV1WorkflowsWorkflowIdDetailGet: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getDetailApiV1WorkflowsWorkflowIdDetailGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/workflows/{workflow_id}/detail`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Jobs
         * @param {string} workflowId 
         * @param {number | null} [limit] Maximum number of jobs to return
         * @param {number | null} [offset] Number of jobs to skip
         * @param {boolean} [orderByStarted] Order by start time (True) or ID (False)
         * @param {boolean} [descending] Order in descending order (newest first)
         * @param {string | null} [ruleName] Filter jobs by rule_name
         * @param {Status | null} [status] Filter jobs by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsApiV1WorkflowsWorkflowIdJobsGet: async (workflowId: string, limit?: number | null, offset?: number | null, orderByStarted?: boolean, descending?: boolean, ruleName?: string | null, status?: Status | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getJobsApiV1WorkflowsWorkflowIdJobsGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/workflows/{workflow_id}/jobs`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderByStarted !== undefined) {
                localVarQueryParameter['order_by_started'] = orderByStarted;
            }

            if (descending !== undefined) {
                localVarQueryParameter['descending'] = descending;
            }

            if (ruleName !== undefined) {
                localVarQueryParameter['rule_name'] = ruleName;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Progress
         * @param {string} workflowId 
         * @param {boolean} [returnTotalJobsNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgressApiV1WorkflowsWorkflowIdProgressGet: async (workflowId: string, returnTotalJobsNumber?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getProgressApiV1WorkflowsWorkflowIdProgressGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/workflows/{workflow_id}/progress`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnTotalJobsNumber !== undefined) {
                localVarQueryParameter['return_total_jobs_number'] = returnTotalJobsNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Rule Graph
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleGraphApiV1WorkflowsWorkflowIdRuleGraphGet: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getRuleGraphApiV1WorkflowsWorkflowIdRuleGraphGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/workflows/{workflow_id}/rule_graph`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Rule Status
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleStatusApiV1WorkflowsWorkflowIdRuleStatusGet: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getRuleStatusApiV1WorkflowsWorkflowIdRuleStatusGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/workflows/{workflow_id}/rule_status`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Snakefile
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnakefileApiV1WorkflowsWorkflowIdSnakefileGet: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getSnakefileApiV1WorkflowsWorkflowIdSnakefileGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/workflows/{workflow_id}/snakefile`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Timelines
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimelinesApiV1WorkflowsWorkflowIdTimelinesGet: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getTimelinesApiV1WorkflowsWorkflowIdTimelinesGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/workflows/{workflow_id}/timelines`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Workflows
         * @param {number | null} [limit] Maximum number of workflows to return
         * @param {number | null} [offset] Number of workflows to skip
         * @param {boolean} [orderByStarted] Order by start time (True) or ID (False)
         * @param {boolean} [descending] Order in descending order (newest first)
         * @param {string | null} [user] Filter by user who started the workflow
         * @param {Status | null} [status] Filter by workflow status (RUNNING, SUCCESS, ERROR, UNKNOWN)
         * @param {string | null} [tags] Filter by tags (comma-separated)
         * @param {string | null} [name] Filter by workflow name
         * @param {string | null} [startAt] Filter workflows started after this time
         * @param {string | null} [endAt] Filter workflows ended before this time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowsApiV1WorkflowsGet: async (limit?: number | null, offset?: number | null, orderByStarted?: boolean, descending?: boolean, user?: string | null, status?: Status | null, tags?: string | null, name?: string | null, startAt?: string | null, endAt?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflows/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderByStarted !== undefined) {
                localVarQueryParameter['order_by_started'] = orderByStarted;
            }

            if (descending !== undefined) {
                localVarQueryParameter['descending'] = descending;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (startAt !== undefined) {
                localVarQueryParameter['start_at'] = (startAt as any instanceof Date) ?
                    (startAt as any).toISOString() :
                    startAt;
            }

            if (endAt !== undefined) {
                localVarQueryParameter['end_at'] = (endAt as any instanceof Date) ?
                    (endAt as any).toISOString() :
                    endAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowApi - functional programming interface
 * @export
 */
export const WorkflowApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflowApiV1WorkflowsWorkflowIdDelete(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkflowApiV1WorkflowsWorkflowIdDelete(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.deleteWorkflowApiV1WorkflowsWorkflowIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsersApiV1WorkflowsUsersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string | null>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsersApiV1WorkflowsUsersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.getAllUsersApiV1WorkflowsUsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Configfiles
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigfilesApiV1WorkflowsWorkflowIdConfigfilesGet(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string | null; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigfilesApiV1WorkflowsWorkflowIdConfigfilesGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.getConfigfilesApiV1WorkflowsWorkflowIdConfigfilesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Detail
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDetailApiV1WorkflowsWorkflowIdDetailGet(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowDetialResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDetailApiV1WorkflowsWorkflowIdDetailGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.getDetailApiV1WorkflowsWorkflowIdDetailGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Jobs
         * @param {string} workflowId 
         * @param {number | null} [limit] Maximum number of jobs to return
         * @param {number | null} [offset] Number of jobs to skip
         * @param {boolean} [orderByStarted] Order by start time (True) or ID (False)
         * @param {boolean} [descending] Order in descending order (newest first)
         * @param {string | null} [ruleName] Filter jobs by rule_name
         * @param {Status | null} [status] Filter jobs by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobsApiV1WorkflowsWorkflowIdJobsGet(workflowId: string, limit?: number | null, offset?: number | null, orderByStarted?: boolean, descending?: boolean, ruleName?: string | null, status?: Status | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobsApiV1WorkflowsWorkflowIdJobsGet(workflowId, limit, offset, orderByStarted, descending, ruleName, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.getJobsApiV1WorkflowsWorkflowIdJobsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Progress
         * @param {string} workflowId 
         * @param {boolean} [returnTotalJobsNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgressApiV1WorkflowsWorkflowIdProgressGet(workflowId: string, returnTotalJobsNumber?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgressApiV1WorkflowsWorkflowIdProgressGet(workflowId, returnTotalJobsNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.getProgressApiV1WorkflowsWorkflowIdProgressGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Rule Graph
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRuleGraphApiV1WorkflowsWorkflowIdRuleGraphGet(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRuleGraphApiV1WorkflowsWorkflowIdRuleGraphGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.getRuleGraphApiV1WorkflowsWorkflowIdRuleGraphGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Rule Status
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRuleStatusApiV1WorkflowsWorkflowIdRuleStatusGet(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: RuleStatusResponse; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRuleStatusApiV1WorkflowsWorkflowIdRuleStatusGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.getRuleStatusApiV1WorkflowsWorkflowIdRuleStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Snakefile
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSnakefileApiV1WorkflowsWorkflowIdSnakefileGet(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSnakefileApiV1WorkflowsWorkflowIdSnakefileGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.getSnakefileApiV1WorkflowsWorkflowIdSnakefileGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Timelines
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimelinesApiV1WorkflowsWorkflowIdTimelinesGet(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<any>; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimelinesApiV1WorkflowsWorkflowIdTimelinesGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.getTimelinesApiV1WorkflowsWorkflowIdTimelinesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Workflows
         * @param {number | null} [limit] Maximum number of workflows to return
         * @param {number | null} [offset] Number of workflows to skip
         * @param {boolean} [orderByStarted] Order by start time (True) or ID (False)
         * @param {boolean} [descending] Order in descending order (newest first)
         * @param {string | null} [user] Filter by user who started the workflow
         * @param {Status | null} [status] Filter by workflow status (RUNNING, SUCCESS, ERROR, UNKNOWN)
         * @param {string | null} [tags] Filter by tags (comma-separated)
         * @param {string | null} [name] Filter by workflow name
         * @param {string | null} [startAt] Filter workflows started after this time
         * @param {string | null} [endAt] Filter workflows ended before this time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowsApiV1WorkflowsGet(limit?: number | null, offset?: number | null, orderByStarted?: boolean, descending?: boolean, user?: string | null, status?: Status | null, tags?: string | null, name?: string | null, startAt?: string | null, endAt?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowsApiV1WorkflowsGet(limit, offset, orderByStarted, descending, user, status, tags, name, startAt, endAt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.getWorkflowsApiV1WorkflowsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkflowApi - factory interface
 * @export
 */
export const WorkflowApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowApiV1WorkflowsWorkflowIdDelete(workflowId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteWorkflowApiV1WorkflowsWorkflowIdDelete(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersApiV1WorkflowsUsersGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<string | null>> {
            return localVarFp.getAllUsersApiV1WorkflowsUsersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Configfiles
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigfilesApiV1WorkflowsWorkflowIdConfigfilesGet(workflowId: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string | null; }> {
            return localVarFp.getConfigfilesApiV1WorkflowsWorkflowIdConfigfilesGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Detail
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailApiV1WorkflowsWorkflowIdDetailGet(workflowId: string, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowDetialResponse> {
            return localVarFp.getDetailApiV1WorkflowsWorkflowIdDetailGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Jobs
         * @param {string} workflowId 
         * @param {number | null} [limit] Maximum number of jobs to return
         * @param {number | null} [offset] Number of jobs to skip
         * @param {boolean} [orderByStarted] Order by start time (True) or ID (False)
         * @param {boolean} [descending] Order in descending order (newest first)
         * @param {string | null} [ruleName] Filter jobs by rule_name
         * @param {Status | null} [status] Filter jobs by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsApiV1WorkflowsWorkflowIdJobsGet(workflowId: string, limit?: number | null, offset?: number | null, orderByStarted?: boolean, descending?: boolean, ruleName?: string | null, status?: Status | null, options?: RawAxiosRequestConfig): AxiosPromise<JobListResponse> {
            return localVarFp.getJobsApiV1WorkflowsWorkflowIdJobsGet(workflowId, limit, offset, orderByStarted, descending, ruleName, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Progress
         * @param {string} workflowId 
         * @param {boolean} [returnTotalJobsNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgressApiV1WorkflowsWorkflowIdProgressGet(workflowId: string, returnTotalJobsNumber?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.getProgressApiV1WorkflowsWorkflowIdProgressGet(workflowId, returnTotalJobsNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Rule Graph
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleGraphApiV1WorkflowsWorkflowIdRuleGraphGet(workflowId: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getRuleGraphApiV1WorkflowsWorkflowIdRuleGraphGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Rule Status
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleStatusApiV1WorkflowsWorkflowIdRuleStatusGet(workflowId: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: RuleStatusResponse; }> {
            return localVarFp.getRuleStatusApiV1WorkflowsWorkflowIdRuleStatusGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Snakefile
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnakefileApiV1WorkflowsWorkflowIdSnakefileGet(workflowId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getSnakefileApiV1WorkflowsWorkflowIdSnakefileGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Timelines
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimelinesApiV1WorkflowsWorkflowIdTimelinesGet(workflowId: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: Array<any>; }> {
            return localVarFp.getTimelinesApiV1WorkflowsWorkflowIdTimelinesGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Workflows
         * @param {number | null} [limit] Maximum number of workflows to return
         * @param {number | null} [offset] Number of workflows to skip
         * @param {boolean} [orderByStarted] Order by start time (True) or ID (False)
         * @param {boolean} [descending] Order in descending order (newest first)
         * @param {string | null} [user] Filter by user who started the workflow
         * @param {Status | null} [status] Filter by workflow status (RUNNING, SUCCESS, ERROR, UNKNOWN)
         * @param {string | null} [tags] Filter by tags (comma-separated)
         * @param {string | null} [name] Filter by workflow name
         * @param {string | null} [startAt] Filter workflows started after this time
         * @param {string | null} [endAt] Filter workflows ended before this time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowsApiV1WorkflowsGet(limit?: number | null, offset?: number | null, orderByStarted?: boolean, descending?: boolean, user?: string | null, status?: Status | null, tags?: string | null, name?: string | null, startAt?: string | null, endAt?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowListResponse> {
            return localVarFp.getWorkflowsApiV1WorkflowsGet(limit, offset, orderByStarted, descending, user, status, tags, name, startAt, endAt, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowApi - object-oriented interface
 * @export
 * @class WorkflowApi
 * @extends {BaseAPI}
 */
export class WorkflowApi extends BaseAPI {
    /**
     * 
     * @summary Delete Workflow
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public deleteWorkflowApiV1WorkflowsWorkflowIdDelete(workflowId: string, options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).deleteWorkflowApiV1WorkflowsWorkflowIdDelete(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public getAllUsersApiV1WorkflowsUsersGet(options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).getAllUsersApiV1WorkflowsUsersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Configfiles
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public getConfigfilesApiV1WorkflowsWorkflowIdConfigfilesGet(workflowId: string, options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).getConfigfilesApiV1WorkflowsWorkflowIdConfigfilesGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Detail
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public getDetailApiV1WorkflowsWorkflowIdDetailGet(workflowId: string, options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).getDetailApiV1WorkflowsWorkflowIdDetailGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Jobs
     * @param {string} workflowId 
     * @param {number | null} [limit] Maximum number of jobs to return
     * @param {number | null} [offset] Number of jobs to skip
     * @param {boolean} [orderByStarted] Order by start time (True) or ID (False)
     * @param {boolean} [descending] Order in descending order (newest first)
     * @param {string | null} [ruleName] Filter jobs by rule_name
     * @param {Status | null} [status] Filter jobs by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public getJobsApiV1WorkflowsWorkflowIdJobsGet(workflowId: string, limit?: number | null, offset?: number | null, orderByStarted?: boolean, descending?: boolean, ruleName?: string | null, status?: Status | null, options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).getJobsApiV1WorkflowsWorkflowIdJobsGet(workflowId, limit, offset, orderByStarted, descending, ruleName, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Progress
     * @param {string} workflowId 
     * @param {boolean} [returnTotalJobsNumber] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public getProgressApiV1WorkflowsWorkflowIdProgressGet(workflowId: string, returnTotalJobsNumber?: boolean, options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).getProgressApiV1WorkflowsWorkflowIdProgressGet(workflowId, returnTotalJobsNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Rule Graph
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public getRuleGraphApiV1WorkflowsWorkflowIdRuleGraphGet(workflowId: string, options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).getRuleGraphApiV1WorkflowsWorkflowIdRuleGraphGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Rule Status
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public getRuleStatusApiV1WorkflowsWorkflowIdRuleStatusGet(workflowId: string, options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).getRuleStatusApiV1WorkflowsWorkflowIdRuleStatusGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Snakefile
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public getSnakefileApiV1WorkflowsWorkflowIdSnakefileGet(workflowId: string, options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).getSnakefileApiV1WorkflowsWorkflowIdSnakefileGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Timelines
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public getTimelinesApiV1WorkflowsWorkflowIdTimelinesGet(workflowId: string, options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).getTimelinesApiV1WorkflowsWorkflowIdTimelinesGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Workflows
     * @param {number | null} [limit] Maximum number of workflows to return
     * @param {number | null} [offset] Number of workflows to skip
     * @param {boolean} [orderByStarted] Order by start time (True) or ID (False)
     * @param {boolean} [descending] Order in descending order (newest first)
     * @param {string | null} [user] Filter by user who started the workflow
     * @param {Status | null} [status] Filter by workflow status (RUNNING, SUCCESS, ERROR, UNKNOWN)
     * @param {string | null} [tags] Filter by tags (comma-separated)
     * @param {string | null} [name] Filter by workflow name
     * @param {string | null} [startAt] Filter workflows started after this time
     * @param {string | null} [endAt] Filter workflows ended before this time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public getWorkflowsApiV1WorkflowsGet(limit?: number | null, offset?: number | null, orderByStarted?: boolean, descending?: boolean, user?: string | null, status?: Status | null, tags?: string | null, name?: string | null, startAt?: string | null, endAt?: string | null, options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).getWorkflowsApiV1WorkflowsGet(limit, offset, orderByStarted, descending, user, status, tags, name, startAt, endAt, options).then((request) => request(this.axios, this.basePath));
    }
}



