/* tslint:disable */
/* eslint-disable */
/**
 * Snakemake Workflow Manager
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface FileResponse
 */
export interface FileResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof FileResponse
     */
    'input': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FileResponse
     */
    'output': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FileResponse
     */
    'log': Array<string>;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * Schema for job list response
 * @export
 * @interface JobListResponse
 */
export interface JobListResponse {
    /**
     * 
     * @type {Array<JobResponse>}
     * @memberof JobListResponse
     */
    'jobs': Array<JobResponse>;
    /**
     * 
     * @type {number}
     * @memberof JobListResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof JobListResponse
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof JobListResponse
     */
    'offset': number;
}
/**
 * Schema for job response
 * @export
 * @interface JobResponse
 */
export interface JobResponse {
    /**
     * 
     * @type {number}
     * @memberof JobResponse
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof JobResponse
     */
    'rule_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'rule_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'workflow_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'started_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'end_time'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof JobResponse
     */
    'threads'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof JobResponse
     */
    'priority'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'shellcmd'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobResponse
     */
    'wildcards'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'reason'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobResponse
     */
    'resources'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Status = {
    Running: 'RUNNING',
    Success: 'SUCCESS',
    Error: 'ERROR',
    Waiting: 'WAITING',
    Unknown: 'UNKNOWN'
} as const;

export type Status = typeof Status[keyof typeof Status];


/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}
/**
 * Schema for workflow list response
 * @export
 * @interface WorkflowListResponse
 */
export interface WorkflowListResponse {
    /**
     * 
     * @type {Array<WorkflowResponse>}
     * @memberof WorkflowListResponse
     */
    'workflows': Array<WorkflowResponse>;
    /**
     * 
     * @type {number}
     * @memberof WorkflowListResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowListResponse
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowListResponse
     */
    'offset': number;
}
/**
 * Schema for workflow response
 * @export
 * @interface WorkflowResponse
 */
export interface WorkflowResponse {
    /**
     * 
     * @type {string}
     * @memberof WorkflowResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResponse
     */
    'snakefile'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResponse
     */
    'started_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResponse
     */
    'end_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResponse
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResponse
     */
    'command_line'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowResponse
     */
    'dryrun': boolean;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof WorkflowResponse
     */
    'run_info'?: { [key: string]: number; } | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResponse
     */
    'user'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkflowResponse
     */
    'configfiles'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResponse
     */
    'directory'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResponse
     */
    'logfile'?: string | null;
}

/**
 * JobsApi - axios parameter creator
 * @export
 */
export const JobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Files
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilesApiV1JobsFilesJobIdGet: async (jobId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getFilesApiV1JobsFilesJobIdGet', 'jobId', jobId)
            const localVarPath = `/api/v1/jobs/files/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Job
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobApiV1JobsJobIdGet: async (jobId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobApiV1JobsJobIdGet', 'jobId', jobId)
            const localVarPath = `/api/v1/jobs/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Files
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilesApiV1JobsFilesJobIdGet(jobId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilesApiV1JobsFilesJobIdGet(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.getFilesApiV1JobsFilesJobIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Job
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobApiV1JobsJobIdGet(jobId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobApiV1JobsJobIdGet(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.getJobApiV1JobsJobIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Files
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilesApiV1JobsFilesJobIdGet(jobId: number, options?: RawAxiosRequestConfig): AxiosPromise<FileResponse> {
            return localVarFp.getFilesApiV1JobsFilesJobIdGet(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Job
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobApiV1JobsJobIdGet(jobId: number, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse> {
            return localVarFp.getJobApiV1JobsJobIdGet(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * 
     * @summary Get Files
     * @param {number} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getFilesApiV1JobsFilesJobIdGet(jobId: number, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).getFilesApiV1JobsFilesJobIdGet(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Job
     * @param {number} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobApiV1JobsJobIdGet(jobId: number, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).getJobApiV1JobsJobIdGet(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LogsApi - axios parameter creator
 * @export
 */
export const LogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Workflow Logs
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowLogsApiV1LogsWorkflowIdGet: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getWorkflowLogsApiV1LogsWorkflowIdGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/logs/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 使用Server-Sent Events格式的实时日志流
         * @summary Stream Workflow Logs Sse
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamWorkflowLogsSseApiV1LogsWorkflowIdSseGet: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('streamWorkflowLogsSseApiV1LogsWorkflowIdSseGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/logs/{workflow_id}/sse`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogsApi - functional programming interface
 * @export
 */
export const LogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Workflow Logs
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowLogsApiV1LogsWorkflowIdGet(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowLogsApiV1LogsWorkflowIdGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogsApi.getWorkflowLogsApiV1LogsWorkflowIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 使用Server-Sent Events格式的实时日志流
         * @summary Stream Workflow Logs Sse
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamWorkflowLogsSseApiV1LogsWorkflowIdSseGet(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamWorkflowLogsSseApiV1LogsWorkflowIdSseGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogsApi.streamWorkflowLogsSseApiV1LogsWorkflowIdSseGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LogsApi - factory interface
 * @export
 */
export const LogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Workflow Logs
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowLogsApiV1LogsWorkflowIdGet(workflowId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getWorkflowLogsApiV1LogsWorkflowIdGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 使用Server-Sent Events格式的实时日志流
         * @summary Stream Workflow Logs Sse
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamWorkflowLogsSseApiV1LogsWorkflowIdSseGet(workflowId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.streamWorkflowLogsSseApiV1LogsWorkflowIdSseGet(workflowId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogsApi - object-oriented interface
 * @export
 * @class LogsApi
 * @extends {BaseAPI}
 */
export class LogsApi extends BaseAPI {
    /**
     * 
     * @summary Get Workflow Logs
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public getWorkflowLogsApiV1LogsWorkflowIdGet(workflowId: string, options?: RawAxiosRequestConfig) {
        return LogsApiFp(this.configuration).getWorkflowLogsApiV1LogsWorkflowIdGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 使用Server-Sent Events格式的实时日志流
     * @summary Stream Workflow Logs Sse
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public streamWorkflowLogsSseApiV1LogsWorkflowIdSseGet(workflowId: string, options?: RawAxiosRequestConfig) {
        return LogsApiFp(this.configuration).streamWorkflowLogsSseApiV1LogsWorkflowIdSseGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SseApi - axios parameter creator
 * @export
 */
export const SseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cleanup Connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupConnectionsApiV1SseCleanupConnectionsPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sse/cleanup-connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Debug Connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugConnectionsApiV1SseDebugConnectionsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sse/debug/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Force Reconnect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceReconnectApiV1SseReconnectPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sse/reconnect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Sse Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSseStatsApiV1SseStatsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sse/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send Test Notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestNotificationApiV1SseTestNotificationPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sse/test-notification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sse Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sseHealthCheckApiV1SseHealthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sse/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Server-Sent Events endpoint for real-time database notifications.  客户端可以连接此端点接收实时通知: - GET /api/v1/sse/events - 接收所有表变化 - GET /api/v1/sse/events?filters=workflows - 只接收workflows表变化 - GET /api/v1/sse/events?filters=jobs&workflow_id=123 - 接收workflows和jobs表变化
         * @summary Stream Events
         * @param {string | null} [filters] Comma-separated list of table names to filter (e.g., \&#39;workflows,jobs\&#39;). Use \&#39;all\&#39; for all tables.
         * @param {string | null} [workflowId] Workflow ID to filter events for a specific workflow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamEventsApiV1SseEventsGet: async (filters?: string | null, workflowId?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sse/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (workflowId !== undefined) {
                localVarQueryParameter['workflow_id'] = workflowId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SseApi - functional programming interface
 * @export
 */
export const SseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cleanup Connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanupConnectionsApiV1SseCleanupConnectionsPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanupConnectionsApiV1SseCleanupConnectionsPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SseApi.cleanupConnectionsApiV1SseCleanupConnectionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Debug Connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debugConnectionsApiV1SseDebugConnectionsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debugConnectionsApiV1SseDebugConnectionsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SseApi.debugConnectionsApiV1SseDebugConnectionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Force Reconnect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forceReconnectApiV1SseReconnectPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forceReconnectApiV1SseReconnectPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SseApi.forceReconnectApiV1SseReconnectPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Sse Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSseStatsApiV1SseStatsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSseStatsApiV1SseStatsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SseApi.getSseStatsApiV1SseStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send Test Notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTestNotificationApiV1SseTestNotificationPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendTestNotificationApiV1SseTestNotificationPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SseApi.sendTestNotificationApiV1SseTestNotificationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sse Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sseHealthCheckApiV1SseHealthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sseHealthCheckApiV1SseHealthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SseApi.sseHealthCheckApiV1SseHealthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Server-Sent Events endpoint for real-time database notifications.  客户端可以连接此端点接收实时通知: - GET /api/v1/sse/events - 接收所有表变化 - GET /api/v1/sse/events?filters=workflows - 只接收workflows表变化 - GET /api/v1/sse/events?filters=jobs&workflow_id=123 - 接收workflows和jobs表变化
         * @summary Stream Events
         * @param {string | null} [filters] Comma-separated list of table names to filter (e.g., \&#39;workflows,jobs\&#39;). Use \&#39;all\&#39; for all tables.
         * @param {string | null} [workflowId] Workflow ID to filter events for a specific workflow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamEventsApiV1SseEventsGet(filters?: string | null, workflowId?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamEventsApiV1SseEventsGet(filters, workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SseApi.streamEventsApiV1SseEventsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SseApi - factory interface
 * @export
 */
export const SseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SseApiFp(configuration)
    return {
        /**
         * 
         * @summary Cleanup Connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupConnectionsApiV1SseCleanupConnectionsPost(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.cleanupConnectionsApiV1SseCleanupConnectionsPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Debug Connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugConnectionsApiV1SseDebugConnectionsGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.debugConnectionsApiV1SseDebugConnectionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Force Reconnect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceReconnectApiV1SseReconnectPost(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.forceReconnectApiV1SseReconnectPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Sse Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSseStatsApiV1SseStatsGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getSseStatsApiV1SseStatsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send Test Notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestNotificationApiV1SseTestNotificationPost(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.sendTestNotificationApiV1SseTestNotificationPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sse Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sseHealthCheckApiV1SseHealthGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.sseHealthCheckApiV1SseHealthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Server-Sent Events endpoint for real-time database notifications.  客户端可以连接此端点接收实时通知: - GET /api/v1/sse/events - 接收所有表变化 - GET /api/v1/sse/events?filters=workflows - 只接收workflows表变化 - GET /api/v1/sse/events?filters=jobs&workflow_id=123 - 接收workflows和jobs表变化
         * @summary Stream Events
         * @param {string | null} [filters] Comma-separated list of table names to filter (e.g., \&#39;workflows,jobs\&#39;). Use \&#39;all\&#39; for all tables.
         * @param {string | null} [workflowId] Workflow ID to filter events for a specific workflow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamEventsApiV1SseEventsGet(filters?: string | null, workflowId?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.streamEventsApiV1SseEventsGet(filters, workflowId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SseApi - object-oriented interface
 * @export
 * @class SseApi
 * @extends {BaseAPI}
 */
export class SseApi extends BaseAPI {
    /**
     * 
     * @summary Cleanup Connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SseApi
     */
    public cleanupConnectionsApiV1SseCleanupConnectionsPost(options?: RawAxiosRequestConfig) {
        return SseApiFp(this.configuration).cleanupConnectionsApiV1SseCleanupConnectionsPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Debug Connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SseApi
     */
    public debugConnectionsApiV1SseDebugConnectionsGet(options?: RawAxiosRequestConfig) {
        return SseApiFp(this.configuration).debugConnectionsApiV1SseDebugConnectionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Force Reconnect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SseApi
     */
    public forceReconnectApiV1SseReconnectPost(options?: RawAxiosRequestConfig) {
        return SseApiFp(this.configuration).forceReconnectApiV1SseReconnectPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Sse Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SseApi
     */
    public getSseStatsApiV1SseStatsGet(options?: RawAxiosRequestConfig) {
        return SseApiFp(this.configuration).getSseStatsApiV1SseStatsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send Test Notification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SseApi
     */
    public sendTestNotificationApiV1SseTestNotificationPost(options?: RawAxiosRequestConfig) {
        return SseApiFp(this.configuration).sendTestNotificationApiV1SseTestNotificationPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sse Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SseApi
     */
    public sseHealthCheckApiV1SseHealthGet(options?: RawAxiosRequestConfig) {
        return SseApiFp(this.configuration).sseHealthCheckApiV1SseHealthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Server-Sent Events endpoint for real-time database notifications.  客户端可以连接此端点接收实时通知: - GET /api/v1/sse/events - 接收所有表变化 - GET /api/v1/sse/events?filters=workflows - 只接收workflows表变化 - GET /api/v1/sse/events?filters=jobs&workflow_id=123 - 接收workflows和jobs表变化
     * @summary Stream Events
     * @param {string | null} [filters] Comma-separated list of table names to filter (e.g., \&#39;workflows,jobs\&#39;). Use \&#39;all\&#39; for all tables.
     * @param {string | null} [workflowId] Workflow ID to filter events for a specific workflow.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SseApi
     */
    public streamEventsApiV1SseEventsGet(filters?: string | null, workflowId?: string | null, options?: RawAxiosRequestConfig) {
        return SseApiFp(this.configuration).streamEventsApiV1SseEventsGet(filters, workflowId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkflowApi - axios parameter creator
 * @export
 */
export const WorkflowApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowApiV1WorkflowsWorkflowIdDelete: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('deleteWorkflowApiV1WorkflowsWorkflowIdDelete', 'workflowId', workflowId)
            const localVarPath = `/api/v1/workflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersApiV1WorkflowsUsersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflows/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Configfiles
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigfilesApiV1WorkflowsWorkflowIdConfigfilesGet: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getConfigfilesApiV1WorkflowsWorkflowIdConfigfilesGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/workflows/{workflow_id}/configfiles`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Jobs
         * @param {string} workflowId 
         * @param {number | null} [limit] Maximum number of jobs to return
         * @param {number | null} [offset] Number of jobs to skip
         * @param {boolean} [orderByStarted] Order by start time (True) or ID (False)
         * @param {boolean} [descending] Order in descending order (newest first)
         * @param {string | null} [ruleName] Filter jobs by rule_name
         * @param {Status | null} [status] Filter jobs by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsApiV1WorkflowsWorkflowIdJobsGet: async (workflowId: string, limit?: number | null, offset?: number | null, orderByStarted?: boolean, descending?: boolean, ruleName?: string | null, status?: Status | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getJobsApiV1WorkflowsWorkflowIdJobsGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/workflows/{workflow_id}/jobs`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderByStarted !== undefined) {
                localVarQueryParameter['order_by_started'] = orderByStarted;
            }

            if (descending !== undefined) {
                localVarQueryParameter['descending'] = descending;
            }

            if (ruleName !== undefined) {
                localVarQueryParameter['rule_name'] = ruleName;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Progress
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgressApiV1WorkflowsWorkflowIdProgressGet: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getProgressApiV1WorkflowsWorkflowIdProgressGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/workflows/{workflow_id}/progress`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the rule graph for a specific workflow
         * @summary Get Rule Graph
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleGraphApiV1WorkflowsWorkflowIdRuleGraphGet: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getRuleGraphApiV1WorkflowsWorkflowIdRuleGraphGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/workflows/{workflow_id}/rule_graph`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Snakefile
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnakefileApiV1WorkflowsWorkflowIdSnakefileGet: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getSnakefileApiV1WorkflowsWorkflowIdSnakefileGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/workflows/{workflow_id}/snakefile`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Timelines
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimelinesApiV1WorkflowsWorkflowIdTimelinesGet: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getTimelinesApiV1WorkflowsWorkflowIdTimelinesGet', 'workflowId', workflowId)
            const localVarPath = `/api/v1/workflows/{workflow_id}/timelines`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all workflows with optional pagination and sorting.
         * @summary Get Workflows
         * @param {number | null} [limit] Maximum number of workflows to return
         * @param {number | null} [offset] Number of workflows to skip
         * @param {boolean} [orderByStarted] Order by start time (True) or ID (False)
         * @param {boolean} [descending] Order in descending order (newest first)
         * @param {string | null} [user] Filter by user who started the workflow
         * @param {Status | null} [status] Filter by workflow status (RUNNING, SUCCESS, ERROR, UNKNOWN)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowsApiV1WorkflowsGet: async (limit?: number | null, offset?: number | null, orderByStarted?: boolean, descending?: boolean, user?: string | null, status?: Status | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflows/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderByStarted !== undefined) {
                localVarQueryParameter['order_by_started'] = orderByStarted;
            }

            if (descending !== undefined) {
                localVarQueryParameter['descending'] = descending;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowApi - functional programming interface
 * @export
 */
export const WorkflowApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflowApiV1WorkflowsWorkflowIdDelete(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkflowApiV1WorkflowsWorkflowIdDelete(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.deleteWorkflowApiV1WorkflowsWorkflowIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsersApiV1WorkflowsUsersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string | null>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsersApiV1WorkflowsUsersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.getAllUsersApiV1WorkflowsUsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Configfiles
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigfilesApiV1WorkflowsWorkflowIdConfigfilesGet(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigfilesApiV1WorkflowsWorkflowIdConfigfilesGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.getConfigfilesApiV1WorkflowsWorkflowIdConfigfilesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Jobs
         * @param {string} workflowId 
         * @param {number | null} [limit] Maximum number of jobs to return
         * @param {number | null} [offset] Number of jobs to skip
         * @param {boolean} [orderByStarted] Order by start time (True) or ID (False)
         * @param {boolean} [descending] Order in descending order (newest first)
         * @param {string | null} [ruleName] Filter jobs by rule_name
         * @param {Status | null} [status] Filter jobs by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobsApiV1WorkflowsWorkflowIdJobsGet(workflowId: string, limit?: number | null, offset?: number | null, orderByStarted?: boolean, descending?: boolean, ruleName?: string | null, status?: Status | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobsApiV1WorkflowsWorkflowIdJobsGet(workflowId, limit, offset, orderByStarted, descending, ruleName, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.getJobsApiV1WorkflowsWorkflowIdJobsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Progress
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgressApiV1WorkflowsWorkflowIdProgressGet(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgressApiV1WorkflowsWorkflowIdProgressGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.getProgressApiV1WorkflowsWorkflowIdProgressGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the rule graph for a specific workflow
         * @summary Get Rule Graph
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRuleGraphApiV1WorkflowsWorkflowIdRuleGraphGet(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRuleGraphApiV1WorkflowsWorkflowIdRuleGraphGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.getRuleGraphApiV1WorkflowsWorkflowIdRuleGraphGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Snakefile
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSnakefileApiV1WorkflowsWorkflowIdSnakefileGet(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSnakefileApiV1WorkflowsWorkflowIdSnakefileGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.getSnakefileApiV1WorkflowsWorkflowIdSnakefileGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Timelines
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimelinesApiV1WorkflowsWorkflowIdTimelinesGet(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimelinesApiV1WorkflowsWorkflowIdTimelinesGet(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.getTimelinesApiV1WorkflowsWorkflowIdTimelinesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all workflows with optional pagination and sorting.
         * @summary Get Workflows
         * @param {number | null} [limit] Maximum number of workflows to return
         * @param {number | null} [offset] Number of workflows to skip
         * @param {boolean} [orderByStarted] Order by start time (True) or ID (False)
         * @param {boolean} [descending] Order in descending order (newest first)
         * @param {string | null} [user] Filter by user who started the workflow
         * @param {Status | null} [status] Filter by workflow status (RUNNING, SUCCESS, ERROR, UNKNOWN)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowsApiV1WorkflowsGet(limit?: number | null, offset?: number | null, orderByStarted?: boolean, descending?: boolean, user?: string | null, status?: Status | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowsApiV1WorkflowsGet(limit, offset, orderByStarted, descending, user, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowApi.getWorkflowsApiV1WorkflowsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkflowApi - factory interface
 * @export
 */
export const WorkflowApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Workflow
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowApiV1WorkflowsWorkflowIdDelete(workflowId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteWorkflowApiV1WorkflowsWorkflowIdDelete(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersApiV1WorkflowsUsersGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<string | null>> {
            return localVarFp.getAllUsersApiV1WorkflowsUsersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Configfiles
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigfilesApiV1WorkflowsWorkflowIdConfigfilesGet(workflowId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getConfigfilesApiV1WorkflowsWorkflowIdConfigfilesGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Jobs
         * @param {string} workflowId 
         * @param {number | null} [limit] Maximum number of jobs to return
         * @param {number | null} [offset] Number of jobs to skip
         * @param {boolean} [orderByStarted] Order by start time (True) or ID (False)
         * @param {boolean} [descending] Order in descending order (newest first)
         * @param {string | null} [ruleName] Filter jobs by rule_name
         * @param {Status | null} [status] Filter jobs by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsApiV1WorkflowsWorkflowIdJobsGet(workflowId: string, limit?: number | null, offset?: number | null, orderByStarted?: boolean, descending?: boolean, ruleName?: string | null, status?: Status | null, options?: RawAxiosRequestConfig): AxiosPromise<JobListResponse> {
            return localVarFp.getJobsApiV1WorkflowsWorkflowIdJobsGet(workflowId, limit, offset, orderByStarted, descending, ruleName, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Progress
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgressApiV1WorkflowsWorkflowIdProgressGet(workflowId: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.getProgressApiV1WorkflowsWorkflowIdProgressGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the rule graph for a specific workflow
         * @summary Get Rule Graph
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleGraphApiV1WorkflowsWorkflowIdRuleGraphGet(workflowId: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getRuleGraphApiV1WorkflowsWorkflowIdRuleGraphGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Snakefile
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnakefileApiV1WorkflowsWorkflowIdSnakefileGet(workflowId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getSnakefileApiV1WorkflowsWorkflowIdSnakefileGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Timelines
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimelinesApiV1WorkflowsWorkflowIdTimelinesGet(workflowId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getTimelinesApiV1WorkflowsWorkflowIdTimelinesGet(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all workflows with optional pagination and sorting.
         * @summary Get Workflows
         * @param {number | null} [limit] Maximum number of workflows to return
         * @param {number | null} [offset] Number of workflows to skip
         * @param {boolean} [orderByStarted] Order by start time (True) or ID (False)
         * @param {boolean} [descending] Order in descending order (newest first)
         * @param {string | null} [user] Filter by user who started the workflow
         * @param {Status | null} [status] Filter by workflow status (RUNNING, SUCCESS, ERROR, UNKNOWN)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowsApiV1WorkflowsGet(limit?: number | null, offset?: number | null, orderByStarted?: boolean, descending?: boolean, user?: string | null, status?: Status | null, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowListResponse> {
            return localVarFp.getWorkflowsApiV1WorkflowsGet(limit, offset, orderByStarted, descending, user, status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowApi - object-oriented interface
 * @export
 * @class WorkflowApi
 * @extends {BaseAPI}
 */
export class WorkflowApi extends BaseAPI {
    /**
     * 
     * @summary Delete Workflow
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public deleteWorkflowApiV1WorkflowsWorkflowIdDelete(workflowId: string, options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).deleteWorkflowApiV1WorkflowsWorkflowIdDelete(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public getAllUsersApiV1WorkflowsUsersGet(options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).getAllUsersApiV1WorkflowsUsersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Configfiles
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public getConfigfilesApiV1WorkflowsWorkflowIdConfigfilesGet(workflowId: string, options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).getConfigfilesApiV1WorkflowsWorkflowIdConfigfilesGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Jobs
     * @param {string} workflowId 
     * @param {number | null} [limit] Maximum number of jobs to return
     * @param {number | null} [offset] Number of jobs to skip
     * @param {boolean} [orderByStarted] Order by start time (True) or ID (False)
     * @param {boolean} [descending] Order in descending order (newest first)
     * @param {string | null} [ruleName] Filter jobs by rule_name
     * @param {Status | null} [status] Filter jobs by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public getJobsApiV1WorkflowsWorkflowIdJobsGet(workflowId: string, limit?: number | null, offset?: number | null, orderByStarted?: boolean, descending?: boolean, ruleName?: string | null, status?: Status | null, options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).getJobsApiV1WorkflowsWorkflowIdJobsGet(workflowId, limit, offset, orderByStarted, descending, ruleName, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Progress
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public getProgressApiV1WorkflowsWorkflowIdProgressGet(workflowId: string, options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).getProgressApiV1WorkflowsWorkflowIdProgressGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the rule graph for a specific workflow
     * @summary Get Rule Graph
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public getRuleGraphApiV1WorkflowsWorkflowIdRuleGraphGet(workflowId: string, options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).getRuleGraphApiV1WorkflowsWorkflowIdRuleGraphGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Snakefile
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public getSnakefileApiV1WorkflowsWorkflowIdSnakefileGet(workflowId: string, options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).getSnakefileApiV1WorkflowsWorkflowIdSnakefileGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Timelines
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public getTimelinesApiV1WorkflowsWorkflowIdTimelinesGet(workflowId: string, options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).getTimelinesApiV1WorkflowsWorkflowIdTimelinesGet(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all workflows with optional pagination and sorting.
     * @summary Get Workflows
     * @param {number | null} [limit] Maximum number of workflows to return
     * @param {number | null} [offset] Number of workflows to skip
     * @param {boolean} [orderByStarted] Order by start time (True) or ID (False)
     * @param {boolean} [descending] Order in descending order (newest first)
     * @param {string | null} [user] Filter by user who started the workflow
     * @param {Status | null} [status] Filter by workflow status (RUNNING, SUCCESS, ERROR, UNKNOWN)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public getWorkflowsApiV1WorkflowsGet(limit?: number | null, offset?: number | null, orderByStarted?: boolean, descending?: boolean, user?: string | null, status?: Status | null, options?: RawAxiosRequestConfig) {
        return WorkflowApiFp(this.configuration).getWorkflowsApiV1WorkflowsGet(limit, offset, orderByStarted, descending, user, status, options).then((request) => request(this.axios, this.basePath));
    }
}



